"""
Fire MDT Incident Service

Complete incident management with state machine, event recording,
and incident lifecycle management.

All timestamps are MDT Unit/Vehicle times, never dispatch times.
"""

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func
from sqlalchemy.orm import selectinload
from datetime import datetime
from typing import Optional, List, Dict, Any
from uuid import UUID, uuid4
import logging

from models.fire_mdt import (
    FireIncident,
    FireIncidentTimeline,
    FireIncidentType,
    FireIncidentStatus,
    FireIncidentPriority,
    TimelineEventType,
    TimelineEventSource,
    GeofenceRole,
    MDTGPSBreadcrumb,
)

logger = logging.getLogger(__name__)


class FireIncidentService:
    """Fire MDT Incident Service - Complete implementation"""

    def __init__(self, db: AsyncSession):
        self.db = db

    # ========================================================================
    # Incident Creation & Management
    # ========================================================================

    async def create_incident(
        self,
        org_id: UUID,
        unit_id: UUID,
        incident_number: str,
        scene_address_text: str,
        incident_type: FireIncidentType = FireIncidentType.FIRE,
        priority: Optional[FireIncidentPriority] = None,
        station_id: Optional[UUID] = None,
        scene_lat: Optional[float] = None,
        scene_lng: Optional[float] = None,
        scene_geofence_meters: int = 300,
        destination_name: Optional[str] = None,
        destination_address_text: Optional[str] = None,
        destination_lat: Optional[float] = None,
        destination_lng: Optional[float] = None,
        destination_geofence_meters: int = 300,
        created_by_user_id: Optional[UUID] = None,
    ) -> FireIncident:
        """
        Create new fire incident with MDT_INCIDENT_GENERATED event.
        
        This is the crew-initiated incident creation. Automatically records
        the first timeline event.
        """
        try:
            # Create incident
            incident = FireIncident(
                org_id=org_id,
                station_id=station_id,
                unit_id=unit_id,
                incident_number=incident_number,
                incident_type=incident_type,
                priority=priority,
                scene_address_text=scene_address_text,
                scene_lat=scene_lat,
                scene_lng=scene_lng,
                scene_geofence_meters=scene_geofence_meters,
                destination_name=destination_name,
                destination_address_text=destination_address_text,
                destination_lat=destination_lat,
                destination_lng=destination_lng,
                destination_geofence_meters=destination_geofence_meters,
                status=FireIncidentStatus.OPEN,
            )
            self.db.add(incident)
            await self.db.flush()

            # Create MDT_INCIDENT_GENERATED timeline event
            await self.record_timeline_event(
                incident_id=incident.id,
                org_id=org_id,
                unit_id=unit_id,
                station_id=station_id,
                event_type=TimelineEventType.MDT_INCIDENT_GENERATED,
                event_time=datetime.utcnow(),
                source=TimelineEventSource.MANUAL,
                confidence=100,
                created_by_user_id=created_by_user_id,
                notes="Incident generated by MDT crew",
            )

            await self.db.commit()
            await self.db.refresh(incident)
            
            logger.info(f"Created incident {incident_number} for unit {unit_id}")
            return incident

        except Exception as e:
            await self.db.rollback()
            logger.error(f"Failed to create incident: {e}")
            raise

    async def record_timeline_event(
        self,
        incident_id: UUID,
        org_id: UUID,
        unit_id: UUID,
        event_type: TimelineEventType,
        event_time: datetime,
        source: TimelineEventSource,
        confidence: int = 100,
        station_id: Optional[UUID] = None,
        lat: Optional[float] = None,
        lng: Optional[float] = None,
        geofence_id: Optional[UUID] = None,
        geofence_role: Optional[GeofenceRole] = None,
        obd_snapshot_id: Optional[UUID] = None,
        override_flag: bool = False,
        override_reason: Optional[str] = None,
        notes: Optional[str] = None,
        created_by_user_id: Optional[UUID] = None,
    ) -> FireIncidentTimeline:
        """
        Record a timeline event - the authoritative state change record.
        
        This is the single source of truth for all operational times.
        """
        try:
            event = FireIncidentTimeline(
                org_id=org_id,
                incident_id=incident_id,
                unit_id=unit_id,
                station_id=station_id,
                event_type=event_type,
                event_time=event_time,
                received_time=datetime.utcnow(),
                source=source,
                confidence=confidence,
                lat=lat,
                lng=lng,
                geofence_id=geofence_id,
                geofence_role=geofence_role,
                obd_snapshot_id=obd_snapshot_id,
                override_flag=override_flag,
                override_reason=override_reason,
                notes=notes,
                created_by_user_id=created_by_user_id,
            )
            self.db.add(event)
            await self.db.flush()

            # Update incident status based on event
            await self._update_incident_status(incident_id, event_type)

            logger.info(f"Recorded {event_type.value} for incident {incident_id}")
            return event

        except Exception as e:
            logger.error(f"Failed to record timeline event: {e}")
            raise

    # ========================================================================
    # State Detection Methods
    # ========================================================================

    async def detect_unit_moving(
        self,
        incident_id: UUID,
        org_id: UUID,
        unit_id: UUID,
        event_time: datetime,
        source: TimelineEventSource,
        lat: Optional[float] = None,
        lng: Optional[float] = None,
        obd_snapshot_id: Optional[UUID] = None,
    ) -> FireIncidentTimeline:
        """Detect and record UNIT_MOVING state"""
        # Check if already recorded
        existing = await self._get_latest_event(incident_id, TimelineEventType.UNIT_MOVING)
        if existing:
            logger.debug(f"UNIT_MOVING already recorded for incident {incident_id}")
            return existing

        return await self.record_timeline_event(
            incident_id=incident_id,
            org_id=org_id,
            unit_id=unit_id,
            event_type=TimelineEventType.UNIT_MOVING,
            event_time=event_time,
            source=source,
            lat=lat,
            lng=lng,
            obd_snapshot_id=obd_snapshot_id,
            notes="Unit departed station/location en route to scene",
        )

    async def detect_on_scene(
        self,
        incident_id: UUID,
        org_id: UUID,
        unit_id: UUID,
        event_time: datetime,
        source: TimelineEventSource,
        lat: Optional[float] = None,
        lng: Optional[float] = None,
        geofence_id: Optional[UUID] = None,
    ) -> FireIncidentTimeline:
        """Detect and record ON_SCENE state"""
        existing = await self._get_latest_event(incident_id, TimelineEventType.ON_SCENE)
        if existing:
            logger.debug(f"ON_SCENE already recorded for incident {incident_id}")
            return existing

        return await self.record_timeline_event(
            incident_id=incident_id,
            org_id=org_id,
            unit_id=unit_id,
            event_type=TimelineEventType.ON_SCENE,
            event_time=event_time,
            source=source,
            lat=lat,
            lng=lng,
            geofence_id=geofence_id,
            geofence_role=GeofenceRole.SCENE,
            notes="Unit arrived at scene",
        )

    async def detect_depart_scene(
        self,
        incident_id: UUID,
        org_id: UUID,
        unit_id: UUID,
        event_time: datetime,
        source: TimelineEventSource,
        lat: Optional[float] = None,
        lng: Optional[float] = None,
    ) -> FireIncidentTimeline:
        """Detect and record DEPART_SCENE state"""
        return await self.record_timeline_event(
            incident_id=incident_id,
            org_id=org_id,
            unit_id=unit_id,
            event_type=TimelineEventType.DEPART_SCENE,
            event_time=event_time,
            source=source,
            lat=lat,
            lng=lng,
            notes="Unit departed scene",
        )

    async def detect_at_destination(
        self,
        incident_id: UUID,
        org_id: UUID,
        unit_id: UUID,
        event_time: datetime,
        source: TimelineEventSource,
        lat: Optional[float] = None,
        lng: Optional[float] = None,
        geofence_id: Optional[UUID] = None,
    ) -> FireIncidentTimeline:
        """Detect and record AT_DESTINATION state"""
        return await self.record_timeline_event(
            incident_id=incident_id,
            org_id=org_id,
            unit_id=unit_id,
            event_type=TimelineEventType.AT_DESTINATION,
            event_time=event_time,
            source=source,
            lat=lat,
            lng=lng,
            geofence_id=geofence_id,
            geofence_role=GeofenceRole.DESTINATION,
            notes="Unit arrived at destination (hospital/etc)",
        )

    async def detect_return_station(
        self,
        incident_id: UUID,
        org_id: UUID,
        unit_id: UUID,
        station_id: UUID,
        event_time: datetime,
        source: TimelineEventSource,
        lat: Optional[float] = None,
        lng: Optional[float] = None,
        geofence_id: Optional[UUID] = None,
    ) -> FireIncidentTimeline:
        """Detect and record RETURN_STATION state"""
        return await self.record_timeline_event(
            incident_id=incident_id,
            org_id=org_id,
            unit_id=unit_id,
            station_id=station_id,
            event_type=TimelineEventType.RETURN_STATION,
            event_time=event_time,
            source=source,
            lat=lat,
            lng=lng,
            geofence_id=geofence_id,
            geofence_role=GeofenceRole.STATION,
            notes="Unit returned to station",
        )

    # ========================================================================
    # Incident Retrieval
    # ========================================================================

    async def get_incident_by_id(self, incident_id: UUID, org_id: UUID) -> Optional[FireIncident]:
        """Get incident by ID with timeline events"""
        try:
            result = await self.db.execute(
                select(FireIncident)
                .options(selectinload(FireIncident.timeline_events))
                .where(
                    and_(
                        FireIncident.id == incident_id,
                        FireIncident.org_id == org_id,
                    )
                )
            )
            return result.scalar_one_or_none()
        except Exception as e:
            logger.error(f"Failed to get incident {incident_id}: {e}")
            return None

    async def get_incident_by_number(self, incident_number: str, org_id: UUID) -> Optional[FireIncident]:
        """Get incident by incident number"""
        try:
            result = await self.db.execute(
                select(FireIncident)
                .options(selectinload(FireIncident.timeline_events))
                .where(
                    and_(
                        FireIncident.incident_number == incident_number,
                        FireIncident.org_id == org_id,
                    )
                )
            )
            return result.scalar_one_or_none()
        except Exception as e:
            logger.error(f"Failed to get incident {incident_number}: {e}")
            return None

    async def get_active_incidents_for_unit(self, unit_id: UUID, org_id: UUID) -> List[FireIncident]:
        """Get all active (non-closed) incidents for a unit"""
        try:
            result = await self.db.execute(
                select(FireIncident)
                .options(selectinload(FireIncident.timeline_events))
                .where(
                    and_(
                        FireIncident.unit_id == unit_id,
                        FireIncident.org_id == org_id,
                        FireIncident.status.in_([FireIncidentStatus.OPEN, FireIncidentStatus.ACTIVE]),
                    )
                )
                .order_by(FireIncident.created_at.desc())
            )
            return list(result.scalars().all())
        except Exception as e:
            logger.error(f"Failed to get active incidents for unit {unit_id}: {e}")
            return []

    async def get_incidents_by_date_range(
        self,
        org_id: UUID,
        start_date: datetime,
        end_date: datetime,
        unit_id: Optional[UUID] = None,
        station_id: Optional[UUID] = None,
    ) -> List[FireIncident]:
        """Get incidents within date range"""
        try:
            query = select(FireIncident).options(selectinload(FireIncident.timeline_events))
            
            conditions = [
                FireIncident.org_id == org_id,
                FireIncident.created_at >= start_date,
                FireIncident.created_at <= end_date,
            ]
            
            if unit_id:
                conditions.append(FireIncident.unit_id == unit_id)
            if station_id:
                conditions.append(FireIncident.station_id == station_id)
            
            query = query.where(and_(*conditions)).order_by(FireIncident.created_at.desc())
            
            result = await self.db.execute(query)
            return list(result.scalars().all())
        except Exception as e:
            logger.error(f"Failed to get incidents by date range: {e}")
            return []

    # ========================================================================
    # Incident Closure
    # ========================================================================

    async def close_incident(
        self,
        incident_id: UUID,
        org_id: UUID,
        unit_id: UUID,
        event_time: datetime,
        created_by_user_id: Optional[UUID] = None,
        notes: Optional[str] = None,
    ) -> FireIncident:
        """
        Close incident with INCIDENT_COMPLETED event.
        
        This finalizes the incident and calculates total mileage.
        """
        try:
            incident = await self.get_incident_by_id(incident_id, org_id)
            if not incident:
                raise ValueError(f"Incident {incident_id} not found")

            # Record completion event
            await self.record_timeline_event(
                incident_id=incident_id,
                org_id=org_id,
                unit_id=unit_id,
                event_type=TimelineEventType.INCIDENT_COMPLETED,
                event_time=event_time,
                source=TimelineEventSource.MANUAL,
                confidence=100,
                created_by_user_id=created_by_user_id,
                notes=notes or "Incident completed and closed",
            )

            # Update incident status
            incident.status = FireIncidentStatus.CLOSED
            incident.closed_at = event_time

            await self.db.commit()
            await self.db.refresh(incident)

            logger.info(f"Closed incident {incident_id}")
            return incident

        except Exception as e:
            await self.db.rollback()
            logger.error(f"Failed to close incident {incident_id}: {e}")
            raise

    # ========================================================================
    # Mileage Calculation from GPS Breadcrumbs
    # ========================================================================

    async def calculate_incident_mileage(self, incident_id: UUID, org_id: UUID) -> float:
        """
        Calculate total mileage for incident from GPS breadcrumbs.
        
        Uses Haversine formula to calculate distance between consecutive GPS points.
        """
        try:
            from math import radians, sin, cos, sqrt, atan2

            # Get all GPS breadcrumbs for this incident, ordered by time
            result = await self.db.execute(
                select(MDTGPSBreadcrumb)
                .where(
                    and_(
                        MDTGPSBreadcrumb.incident_id == incident_id,
                        MDTGPSBreadcrumb.org_id == org_id,
                    )
                )
                .order_by(MDTGPSBreadcrumb.gps_time.asc())
            )
            breadcrumbs = list(result.scalars().all())

            if len(breadcrumbs) < 2:
                logger.debug(f"Insufficient GPS data for mileage calculation: {len(breadcrumbs)} points")
                return 0.0

            total_distance_miles = 0.0
            
            for i in range(1, len(breadcrumbs)):
                prev = breadcrumbs[i - 1]
                curr = breadcrumbs[i]

                # Haversine formula for great circle distance
                lat1, lon1 = radians(float(prev.lat)), radians(float(prev.lng))
                lat2, lon2 = radians(float(curr.lat)), radians(float(curr.lng))

                dlat = lat2 - lat1
                dlon = lon2 - lon1

                a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2
                c = 2 * atan2(sqrt(a), sqrt(1 - a))

                # Earth radius in miles
                distance_miles = 3958.8 * c
                
                # Filter out unrealistic jumps (> 100 mph assuming 1 second between points)
                if distance_miles < 0.028:  # ~100 mph for 1 second
                    total_distance_miles += distance_miles

            logger.info(f"Calculated mileage for incident {incident_id}: {total_distance_miles:.2f} miles")
            return round(total_distance_miles, 2)

        except Exception as e:
            logger.error(f"Failed to calculate mileage for incident {incident_id}: {e}")
            return 0.0

    # ========================================================================
    # Helper Methods
    # ========================================================================

    async def _get_latest_event(
        self, incident_id: UUID, event_type: TimelineEventType
    ) -> Optional[FireIncidentTimeline]:
        """Get the latest event of a specific type for an incident"""
        try:
            result = await self.db.execute(
                select(FireIncidentTimeline)
                .where(
                    and_(
                        FireIncidentTimeline.incident_id == incident_id,
                        FireIncidentTimeline.event_type == event_type,
                    )
                )
                .order_by(FireIncidentTimeline.event_time.desc())
                .limit(1)
            )
            return result.scalar_one_or_none()
        except Exception as e:
            logger.error(f"Failed to get latest event: {e}")
            return None

    async def _update_incident_status(self, incident_id: UUID, event_type: TimelineEventType):
        """Update incident status based on timeline event"""
        try:
            incident = await self.db.get(FireIncident, incident_id)
            if not incident:
                return

            # Status transitions based on events
            if event_type in [
                TimelineEventType.UNIT_MOVING,
                TimelineEventType.ON_SCENE,
                TimelineEventType.DEPART_SCENE,
            ]:
                incident.status = FireIncidentStatus.ACTIVE
            elif event_type == TimelineEventType.INCIDENT_COMPLETED:
                incident.status = FireIncidentStatus.CLOSED
                incident.closed_at = datetime.utcnow()

        except Exception as e:
            logger.error(f"Failed to update incident status: {e}")
